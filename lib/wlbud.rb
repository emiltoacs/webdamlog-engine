# ####License####
#  File name wlbud.rb
#  Copyright Â© by INRIA
#
#  Contributors : Webdam Team <webdam.inria.fr>
#       Jules Testard <jules[dot]testard[@]mail[dot]mcgill[dot]ca>
#       Emilien Antoine <emilien[dot]antoine[@]inria[dot]fr>
#
#   WebdamLog - 30 juin 2011
#
#   Encoding - UTF-8
# ####License####
module WLBud

  PATH_LIB = File.expand_path(File.dirname(__FILE__))
  PATH_WLBUD = File.expand_path("wlbud/", PATH_LIB)
  PATH_CONFIG = File.expand_path("config/", PATH_LIB)
  RULE_DIR_NAME = "wlrule_to_bud"
  PATH_BUD = File.expand_path("bud/", PATH_LIB)
  # No modification of the load path in a gem #$:.unshift PATH_WLBUD unless
  # $LOAD_PATH.include?(PATH_WLBUD) #$:.unshift PATH_LIB unless
  # $LOAD_PATH.include?(PATH_LIB) #$:.unshift PATH_CONFIG unless
  # $LOAD_PATH.include?(PATH_CONFIG)

  # control bud gem version
  require "#{PATH_WLBUD}/version"
  require 'rubygems'
  gem 'bud', ">= #{WLBud::BUD_GEM_VERSION}"
  require 'bud'
  require 'bud/viz_util'
  require 'polyglot'
  require 'treetop'
  require 'yaml'
  require 'prettyprint'
  # stdlib
  require 'set'
  require 'benchmark'

  # #file project
  require "#{PATH_WLBUD}/wlprogram"
  require "#{PATH_WLBUD}/wlpacket"
  require "#{PATH_WLBUD}/wlerror"
  require "#{PATH_WLBUD}/wlchannel"
  require "#{PATH_WLBUD}/wlvocabulary"
  # file project: automatically generated by polyglot but could also be compiled
  # via tt
  require "#{PATH_WLBUD}/wlgrammar"
  # #file tool project
  require "#{PATH_WLBUD}/tools/wltools"

  # Override bud methods
  require "#{PATH_BUD}/budoverride"

  # :title:WLBud WLBud is a Ruby Module that simulates WebdamLog behavior using
  # Bud. :main:WLBud


  # TODO: remove class to force user to create a new class that include WLBud.
  #   It is very unlikely that any user wants to instantiate this class directly
  #   since all the method adding(and so the rules) would be share by all the
  #   instances.
  #
  # Alternative: we could change the code code to add methods to instance of
  # objects instead of the class (lots of refactoring)
  #
  class WL
    include WLBud

    # The name of the peer
    attr_reader :peername
    # The name of the file to read with the program
    attr_reader :filename
    attr_reader :options, :wl_program, :rules_to_delegate, :relation_to_declare, :program_loaded
    # the directory where the peer write its rules
    attr_reader :rule_dir
    attr_reader :filter_delegations, :pending_delegations

    # TODO: define the following attributes only if options[:wl_test]

    # @return the content returned by read_packet_channel at the beginning of
    #   the tick (an array of WLPacketData)
    attr_reader :test_received_on_chan
    attr_reader :test_send_on_chan, :wl_callback, :wl_callback_step


    # The initializer for WLBud directly overrides the initializer from Bud.
    #
    # Override bud method
    #
    # ==== Attributes
    #
    # * +peername+ identifier for this peer, should be a string unique
    # * +pgfilename+ the filename containing the program (or any IO object
    #   readable)
    # * +options+
    #
    # ==== Options
    #
    # * +:rule_dir+ the name of the directory in which the file with the rule
    #   will be stored.
    # * +:debug+ very verbose debug
    # * +:measure+ put this flag to generate a report with measurement of
    #   internal tick steps.
    # * +:delay_fact_loading+ if true does not load the program hence before you
    #   can run the peer you shall call the load_program method. Used with
    #   wrapper that required to be bind before we have started to add facts
    #   into them
    # * +:filter_delegations+ if true all the delegation will be put in a
    #   waiting queue  instead of being added to the program. Some external
    #   intervention will be required to validate them.
    def initialize (peername, pgfilename, options={})
      # ### WLBud:Begin adding to Bud special bud parameter initialization
      if options[:mesure]
        @start_time = Time.now
      end
      # Name of that peer
      @peername = peername
      # TODO check if already created it may contains previous entries to load
      # since it may be a peer that has been restarted Directory to store rules
      # in files to be parsed by bud
      @rule_dir = create_rule_dir(options[:rule_dir])
      raise WLError, "you must give or provide read and write access to a file for reading rules to provide to bud, but it seems impossible with: #{@rule_dir}" unless File.writable?(@rule_dir)
      # #debug message
      options[:debug] ||= false
      $BUD_DEBUG ||= options[:bud_debug]
      # #additional module with bud block to import
      options[:modulename] ||= nil
      WLTools::Debug_messages.h1 "Peer #{@peername} start of initialization" if options[:debug]
      @filename = pgfilename
      # This flag is set to true when the wl_program is made via the
      # make_program method. It is used to consider the delegation spawned by
      # the program evaluation.
      @fist_tick_after_make_program=false
      # It represents the list of new delegations to send at this tick.
      #
      # ===Details
      # Hash where key="peer_name destination" and values are all the rules to
      # be sent to the peer in key in the wlprogam input format. Basically rules
      # can come into this Hash only from rule rewriting or come from a seed
      # rule that have new values at this tick.
      @rules_to_delegate = Hash.new{ |h,k| h[k]=Array.new }
      # It represents the list of new relation declarations to send at this
      # tick.
      #
      # ===Details
      # New relations to declare on remote peers, these are the intermediary
      # ones appearing in one of the delegations in rules_to_delegate.
      @relation_to_declare = Hash.new{ |h,k| h[k]=Array.new }
      # if true rule received will be placed into pending_delegations instead of
      # being added
      @filter_delegations = options[:filter_delegations] ||= false

      if options[:wl_test]
        @test_received_on_chan = []
        @test_send_on_chan = []
        @wl_callback = {}
        @wl_callback_id = 0
        @wl_callback_step = Set[ :callback_step_received_on_chan,
          :callback_step_write_on_chan,
          :callback_step_write_on_chan_2,
          :callback_step_end_tick ]
      end
      # ### WLBud:End adding to Bud
      options[:dump_rewrite] ||= ENV["BUD_DUMP_REWRITE"].to_i > 0
      options[:dump_ast]     ||= ENV["BUD_DUMP_AST"].to_i > 0
      options[:print_wiring] ||= ENV["BUD_PRINT_WIRING"].to_i > 0
      @qualified_name = ""
      @tables = {}
      @lattices = {}
      @channels = {}
      @dbm_tables = {}
      @zk_tables = {}
      @stratified_rules = []
      @push_elems = {}
      @callbacks = {}
      @callback_id = 0
      @shutdown_callbacks = {}
      @shutdown_callback_id = 0
      @post_shutdown_callbacks = []
      @timers = []
      @app_tables = []
      @inside_tick = false
      @tick_clock_time = nil
      @budtime = 0
      @inbound = {}
      @done_bootstrap = false
      @done_wiring = false
      @instance_id = ILLEGAL_INSTANCE_ID # Assigned when we start running
      @metrics = {}
      @endtime = nil
      @this_stratum = 0
      @push_sorted_elems = nil
      @running_async = false
      @bud_started = false

      # Setup options (named arguments), along with default values
      @options = options.clone
      @options[:ip] ||= "127.0.0.1"
      @ip = @options[:ip]
      @options[:port] ||= 0
      @options[:port] = @options[:port].to_i
      # NB: If using an ephemeral port (specified by port = 0), the actual port
      # number won't be known until we start EM

      load_lattice_defs
      builtin_state

      # #### WLBud:Begin adding to Bud
      #
      # #Loads .wl file containing the setup(facts and rules) for the
      #   Webdamlog instance.
      @wl_program = WLBud::WLProgram.new( @peername, @filename, @ip, @options[:port], false, {:debug => @options[:debug]} )
      @wl_program.flush_new_local_declaration
      @wlb_tmp_inc=0
      @need_rewrite_strata=false
      @done_rewrite={}
      @collection_added=false
      # @!attributes [Hash] if filter_delegations is true, delegations received
      #   from other peers are put in this hash peername: timestamp: rule1 rule2
      @pending_delegations = Hash.new{ |h,k| h[k]=Hash.new{ |h2,k2| h2[k2]=Array.new } }

      # XXX : added comments on budlib (unofficial):
      # - wlbud => initialize
      # - bud.rb => rewrite_local_methods
      # - bud_meta.rb => rewrite_rule_block Bloom programs consists of Bloom
      #   Blocks that are interpreted as instance methods by the bud compiler
      #   with a certain format (__bloom__.+ in regex). What we do is create new
      #   such methods from our .wl file for the class and give them an
      #   appropriate name, so that Bud believes these are methods identical to
      #   his bloom do.
      unless @wl_program.empty? or @wl_program.collection_empty?
        make_bud_program
      else
        raise WLError, "the program is empty, impossible to generate corresponding facts and rules"
      end
      @fist_tick_after_make_program=true
      # ### WLBud:End adding to Bud

      resolve_imports
      call_state_methods

      @viz = VizOnline.new(self) if @options[:trace]
      @rtracer = RTrace.new(self) if @options[:rtrace]

      # #WLBud:Begin alternative to Bud Contains all the code needed to build
      # dependency graph and organize it in strata for bud semi-naive
      # evaluation. Some bud legacy code plus incremental adding rule methods
      rewrite_strata
      WLTools::Debug_messages.h1 "Peer #{@peername} end of initialization" if @options[:debug]
      # ### WLBud:End alternative to Bud
    end

    # if :delay_fact_loading is true you should call this to evaluate facts in
    # the bootstrap program. This will insert all the facts parsed by the
    # program from the beginning.
    def load_bootstrap_fact
      self.sync_do do
        @wl_program.wlfacts.each { |fact| add_facts(fact) }
        @program_loaded = true
      end
    end

    # It is not intended to be called directly by client code. From client code,
    # call tick which will call start(true) allowing the EventMachine to call
    # the tick_internal.
    #
    # Override bud method Bud.tick_internal.
    #
    def tick_internal
      # ### WLBud:Begin adding to Bud
      #
      # part 1: setup
      if @options[:debug]
        puts "==================================================================\n"
        puts "\t\t\tOutput for internal tick turn #{budtime}\n"
      end
      if @options[:mesure]
        timetick = {}
        timetick[@budtime] = []
        beginning_time = Time.now
      end
      # TODO: improvement relation_to_declare and rules_to_delegate could be
      # emptied only when a ack message is received from remote peers to be sure
      # that rules and relations have been correctly installed.
      if @fist_tick_after_make_program
        @relation_to_declare.merge!(@wl_program.flush_new_relations_to_declare_on_remote_peer){|key,oldv,newv| oldv<<newv}
        @rules_to_delegate.merge!(@wl_program.flush_new_delegations_to_send){|key,oldv,newv| oldv<<newv}
        @fist_tick_after_make_program=false
        @fist_tick_after_make_program.freeze
      else
        @relation_to_declare.clear
        @rules_to_delegate.clear
      end
      # already in bud but I moved receive_inbound before all the stuff about
      # app_tables, push_sorted_elements, ...
      receive_inbound
      # ### WLBud:End adding to Bud

      puts "#{object_id}/#{port} : ============================================= (#{@budtime})" if $BUD_DEBUG
      begin
        starttime = Time.now if @options[:metrics]
        if @options[:metrics] and not @endtime.nil?
          @metrics[:betweentickstats] ||= initialize_stats
          @metrics[:betweentickstats] = running_stats(@metrics[:betweentickstats],
            starttime - @endtime)
        end

        @inside_tick = true

        # ### WLBud:Begin adding to Bud
        if @options[:mesure]
          end_time = Time.now
          timetick[@budtime] << end_time - beginning_time
          inter_time = end_time
        end
        if @options[:wl_test]
          # callback insertion of callback_step_received_on_chan Marshalling is
          # used to deep duplicate the object
          @test_received_on_chan = Marshal.load(Marshal.dump(read_packet_channel))
          @wl_callback.each_value do |callback|
            if callback[0] == :callback_step_received_on_chan
              block = callback[1]
              if block.respond_to?(:call)
                block.call(self)
              else
                raise WLErrorCallback,
                  "Trying to call a callback method that is not responding to call #{block}"
              end
            end
          end
        end
        read_packet_channel.each do |packet_value|
          if @options[:debug]
            puts "Process packets received from #{packet_value.print_meta_data}"
            puts "---------"
          end
          if @options[:filter_delegations]
            packet_value.declarations.each { |dec| add_collection(dec) } unless packet_value.declarations.nil?
            @pending_delegations[packet_value.peer_name.to_sym][packet_value.src_time_stamp] << packet_value.rules
            add_facts(packet_value.facts) unless packet_value.facts.nil?
          else
            # Declare all the new relations and insert the rules
            packet_value.declarations.each { |dec| add_collection(dec) } unless packet_value.declarations.nil?
            packet_value.rules.each{ |rule| add_rule(rule) } unless packet_value.rules.nil?
            add_facts(packet_value.facts) unless packet_value.facts.nil?
          end
        end

        if @need_rewrite_strata
          rewrite_strata
          @done_wiring=false
          puts "do_wiring at tick #{budtime}" if @options[:debug]
          do_wiring
          @viz = VizOnline.new(self) if @options[:trace]
          @need_rewrite_strata=false
        elsif @collection_added # only if collections have been added and do_wiring has not been called because no new rules appeared
          update_app_tables
          @collection_added = false
        end
        if @options[:mesure]
          end_time = Time.now
          timetick[@budtime] << end_time - inter_time
          inter_time = end_time
        end
        # ### WLBud:End adding to Bud

        unless @done_bootstrap
          do_bootstrap
          do_wiring
        else
          # inform tables and elements about beginning of tick.
          @app_tables.each {|t| t.tick}
          @default_rescan.each {|elem| elem.rescan = true}
          @default_invalidate.each {|elem|
            elem.invalidated = true
            # Call tick on tables here itself. The rest below
            elem.invalidate_cache unless elem.class <= PushElement
          }

          # The following loop invalidates additional (non-default) elements and
          # tables that depend on the run-time invalidation state of a table.
          # Loop once to set the flags.
          each_scanner do |scanner, stratum|
            if scanner.rescan
              scanner.rescan_set.each {|e| e.rescan = true}
              scanner.invalidate_set.each {|e|
                e.invalidated = true
                e.invalidate_cache unless e.class <= PushElement
              }
            end
          end

          # Loop a second time to actually call invalidate_cache.  We can't
          # merge this with the loops above because some versions of
          # invalidate_cache (e.g., join) depend on the rescan state of other
          # elements.
          @num_strata.times do |stratum|
            @push_sorted_elems[stratum].each {|e| e.invalidate_cache if e.invalidated}
          end
        end

        # ### WLBud:Begin adding to Bud
        #
        # #part 2: logic
        #
        if @options[:mesure]
          end_time = Time.now
          timetick[@budtime] << end_time - inter_time
          inter_time = end_time
        end
        # removed receive_inbound since it has been done earlier ### WLBud:End
        # adding to Bud compute fixpoint for each stratum in order
        @stratified_rules.each_with_index do |rules,stratum|
          fixpoint = false
          first_iter = true
          until fixpoint
            @scanners[stratum].each_value {|s| s.scan(first_iter)}
            fixpoint = true
            first_iter = false
            # flush any tuples in the pipes
            @push_sorted_elems[stratum].each {|p| p.flush}
            # tick deltas on any merge targets and look for more deltas check to
            # see if any joins saw a delta
            @push_joins[stratum].each do |p|
              if p.found_delta
                fixpoint = false
                p.tick_deltas
              end
            end
            @merge_targets[stratum].each do |t|
              fixpoint = false if t.tick_deltas
            end
          end

          # push end-of-fixpoint
          @push_sorted_elems[stratum].each do |p|
            p.stratum_end
          end
          @merge_targets[stratum].each do |t|
            t.flush_deltas
          end
        end
        @viz.do_cards(true) if @options[:trace]

        # part 3: transition
        #
        # ##WLBud:Begin adding to Bud
        #
        if @options[:mesure]
          end_time = Time.now
          timetick[@budtime] << end_time - inter_time
          inter_time = end_time
        end
        # diplay the content of dbm
        if @options[:debug] and @options[:trace]
          puts "-----see viz logtab dbm-----"
          # #logtab = @viz.class.send(:logtab) #dbm = logtab.class.send(:dbm)
          logtab = @viz.instance_eval{ @logtab }
          dbm = logtab.instance_eval{ @dbm }
          # #dbm.each{ |o| puts "#{o.class} : #{o}" } #logtab.each_storage{ |s|
          # puts s }
          logtab.to_a.sort_by{ |t| [t[0],t[1]] }.each{|s| puts s}
          # #logtab.to_a.sort{ |t1,t2| [t1[0],t1[1]] <=> [t2[0],t2[1]]
          # }.each{|s| puts s} # same result as above
          puts "----end of viz logtab-----"
        end
        # There is the moment in the tick where I should fill the channel with
        # my own structure that is the facts, the delegated rules along with the
        # newly created relations (declaration of new collections)
        write_packet_on_channel
        if @options[:mesure]
          end_time = Time.now
          timetick[@budtime] << end_time - inter_time
          inter_time = end_time
        end
        #
        # ### WLBud:End adding to Bud

        do_flush

        invoke_callbacks
        @budtime += 1
        @inbound.clear
        @reset_list.each { |e| e.invalidated = false; e.rescan = false }

      ensure
        @inside_tick = false
        @tick_clock_time = nil
      end

      if @options[:wl_test]
        @wl_callback.each_value do |callback|
          if callback[0] == :callback_step_end_tick
            block = callback[1]
            unless block.respond_to?(:call)
              raise WLErrorCallback,
                "Trying to call a callback method that is not responding to call #{block}"
            end
            block.call(self)
          end
        end
      end

      if @options[:metrics]
        @endtime = Time.now
        @metrics[:tickstats] ||= initialize_stats
        @metrics[:tickstats] = running_stats(@metrics[:tickstats], @endtime - starttime)
      end

      if @options[:debug] then
        puts "==================================================================\n"
      end
      if @options[:mesure]
        end_time = Time.now
        timetick[@budtime-1] << end_time - inter_time
        timetick[@budtime-1] << end_time - beginning_time
        wltime=timetick[@budtime-1][1]+timetick[@budtime-1][4]
        budtime=timetick[@budtime-1][0]+timetick[@budtime-1][3]+timetick[@budtime-1][5]
        mixin=timetick[@budtime-1][2]
        if @options[:measure_file].nil?
          benchmark_file_log = File.new("benchark_time_log_#{options[:tag]}", "a+")
        else
          benchmark_file_log = File.new(@options[:measure_file], "a+")
        end
        puts "time to tick #{@budtime-1} : #{timetick[@budtime-1].inspect} ; wltime=#{wltime} ; budtime=#{budtime} ; mixin=#{mixin}" if @options[:debug]
        benchmark_file_log.puts "array = #{timetick[@budtime-1].inspect} ; wltime=#{wltime} ; budtime=#{budtime} ; mixin=#{mixin}"
        benchmark_file_log.close
      end
    end

    # Override the method in bud to create some additional relations. It is
    # called in init_state in the initializer in the bud original class. The bud
    # builtin_state define the builtin collections of bud such as local-tick,
    # stdio, signals, halt and periodics_tbl. In this method we add our
    # communication methods needed to send package as big pack of data using
    # WLchannel.
    #
    # Extend bud method
    #
    def builtin_state
      super
      # Contains the times nodes informations TODO: facts should be the list of
      # facts used to derive head: define field to use(some kind of id)
      table :t_derivation, [:rule_id, :facts] => [:derivated]
      @builtin_tables = @tables.clone if toplevel
      # Unique channel that serves for all messages. Each timestep exactly one
      # or zero packet is sent to each peer (see wlpacket).
      wlchannel :chan, [:@dst,:packet] => []
      # This is the buffer in which we put all the facts we want to send, its
      # schema is very simple [:@dst, :rel_name, :facts] where :@dst should be
      # the destination where to send the facts in the same format as :@dst in
      # standard bud channel "ip:port"
      scratch :sbuffer, [:dst, :rel_name, :fact] => []
    end

    # WLBud:Begin alternative to Bud rewrite_strata rewrites the dependency
    # graph of the program in a topological order. This is a necessary step each
    # time the program is modified. It's nearly the same code as in bud but we
    # put it in a separated method to be called after program update.
    #
    def rewrite_strata
      WLTools::Debug_messages.h2 "Peer #{@peername} start to rewrite strata" if @options[:debug]
      # Rebuild the list of methods to shred in do_rewrite->shred_rules
      @declarations = self.class.instance_methods.select {|m| m =~ /^__bloom__.+$/}.map {|m| m.to_s}
      # Erase all previous rules and dependence as we rebuild the graph from
      # scratch
      self.t_rules.storage.clear
      self.t_depends.storage.clear
      # self.t_table_info.send :init_buffers self.t_table_schema.send
      # :init_buffers Need to manually erase strata
      self.t_stratum.storage.clear
      self.t_stratum.delta.clear
      # WLBud:End the rest is the legacy bud code

      do_rewrite

      if toplevel == self
        # initialize per-stratum state
        @num_strata = @stratified_rules.length
        @scanners = @num_strata.times.map{{}}
        @push_sources = @num_strata.times.map{{}}
        @push_joins = @num_strata.times.map{[]}
        @merge_targets = @num_strata.times.map{Set.new}
      end
    end

    # WLBud:Begin alternative to Bud this is the preamble to do_wiring which
    # prepare active tables in the application to be used in fixpoint
    def update_app_tables
      # Prepare list of tables that will be actively used at run time. First,
      # all the user-defined tables and lattices.  We start @app_tables off as a
      # set, then convert to an array later.
      @app_tables = (@tables.keys - @builtin_tables.keys).map {|t| @tables[t]}.to_set
      @app_tables.merge(@lattices.values)

      # Check scan and merge_targets to see if any builtin_tables need to be
      # added as well.
      @scanners.each do |scs|
        @app_tables.merge(scs.values.map {|s| s.collection})
      end
      @merge_targets.each do |mts| #mts == merge_targets at stratum
        @app_tables.merge(mts)
      end
      @app_tables = @app_tables.to_a
    end

    # override do_wiring to force all merge target to accumulate tick delta for
    # callbacks in applications
    def do_wiring
      super
      @merge_targets.each_with_index do |stratum_targets, stratum|
        stratum_targets.each {|tab|
          tab.accumulate_tick_deltas = true # if stratum_accessed[tab] and stratum_accessed[tab] > stratum # no condition
        }
      end
    end

    # This method will translate one wlrule in parameter into Bud rule format
    # and make bud evaluate it as method of its class. It return the name of the
    # block created that is the name of the rule in bud.
    #
    # ==== Remark
    #
    # Because of new 0.9.1 bud evaluation system, it is needed to create a file
    # in which bud is supposed to read the rule instead of just reading a block
    # dynamically created.
    #
    def translate_rule(wlrule)
      @wl_program.disamb_peername!(wlrule)
      rule = "#{@wl_program.translate_rule_str(wlrule)}"
      name = "webdamlog_#{@peername}_#{wlrule.rule_id}"
      str = build_string_rule_to_include(name, rule)
      fullfilename = File.join(@rule_dir,name)
      fout = File.new("#{fullfilename}", "w+")
      fout.puts "#{str}"
      fout.close
      if @options[:debug]
        puts "Content of the tmp file is:\n#{File.readlines(fullfilename).each{|f| f }}\n"
      end
      load fullfilename
      # extract from how bud creates name for its block
      return "__bloom__#{name}"
    end

    # Build the bloom block to insert in bud with the given rule inside and as
    # name of the block "sym_name"
    #
    def build_string_rule_to_include (sym_name, rule)
      # Does not require to load anything since it is suppose to be loaded in
      # the good environment str = "require '#{__FILE__}'\n"
      str = "class #{self.class}\n"
      str << "\tbloom :#{sym_name} do\n"
      str << "\t\t#{rule}\n"
      str << "\tend\n"
      str << "end"
      return str
    end

    # Used to add a new relation into bud from a wlcollection to declare. Should
    # be used to declare all collection that should be declared in a state block
    # in bloom.
    #
    # @param [WLCollection] wlcollection that should be declared in bud @param
    # colltype must be a sub class of Bud::Collection. It is use to force the
    # declaration of the given type of Bud Collection for this WLCollection. Use
    # it in test only as the method is supposed to parse correctly the
    # WLCollection @param args optional args if colltype is a channel then args
    # could be "loopback"
    #
    def schema_init(wlcollection, colltype=nil, *args)
      name = wlcollection.atom_name.to_sym
      if colltype.nil?
        if wlcollection.persistent?
          self.table(name,wlcollection.schema)
        else
          self.scratch(wlcollection.atom_name.to_sym,wlcollection.schema)
        end
      else
        # Force the type of the collection to declare (non-conventional policy
        # for test)
        if colltype=="table"
          self.table(name,wlcollection.schema)
        else if colltype=="scratch"
            self.scratch(name,wlcollection.schema)
          else if colltype=="channel"
              if args.first=="loopback"
                self.channel(name,wlcollection.schema,true)
              else
                self.channel(name,wlcollection.schema)
              end
            else
              raise WLError, "trying to force the type of a collection to a non-supported format"
            end
          end
        end
      end # if colltype.nil?
      return @tables[name].tabname, @tables[name].schema
    end # schema_init

    # Adds dynamically facts
    #
    def add_facts(wl_facts)
      facts, err = {}
      if wl_facts.is_a? Hash
        valid, msg = WLPacketData.valid_hash_of_facts wl_facts
        if valid
          facts, err = insert_updates(wl_facts)
        else
          raise WLErrorTyping, msg
        end
      else
        if wl_facts.is_a? WLBud::WLFact
          fact = {wl_facts.fullrelname => [wl_facts.content] }
          facts, err = add_facts fact
        elsif wl_facts.is_a? String
          fact = @wl_program.parse(wl_facts, true)
          if fact.is_a? WLBud::WLFact
            facts, err = add_facts fact
          else
            raise WLErrorTyping, "fact string is not considered as a fact construct, but is #{fact.class} : #{fact}"
          end
        else
          raise WLErrorTyping, "fact is not considered as a fact construct, but is of class #{wl_facts.class}"
        end
      end
      return facts, err
    end

    # It will dynamically add a collection to the program
    #
    # * +wlpg_relation+ is a string representing the rule in the wl_program file
    #   format(wlgrammar). @return [String, Hash] name, schema of the collection
    #   added
    #
    def add_collection(wlpg_relation)
      if wlpg_relation.is_a?(WLBud::WLCollection)
        collection = wlpg_relation
      else
        collection = @wl_program.parse(wlpg_relation, true)
      end
      raise WLErrorProgram, "parse relation and get #{collection.class}" unless collection.is_a?(WLBud::WLCollection)
      valid, msg = @wl_program.valid_collection? collection
      raise WLErrorProgram, msg unless valid
      puts "Adding a collection: \n #{collection.show}" if @options[:debug]
      name, schema = self.schema_init(collection)
      @collection_added = true
      return name.to_s, schema
    end

    # Takes in a string representing a WLRule, parses it and adds it directly
    # into the WLBud instance.
    #
    # @raise [WLError] if something goes wrong
    # @return [Array] rule_id, rule string of the local rule installed or nil if the rule is fully delegated.
    def add_rule(wlpg_rule)
      rule = @wl_program.parse(wlpg_rule, true)
      raise WLErrorProgram, "parse rule and get #{rule.class}" unless rule.is_a?(WLBud::WLRule)
      unless @wl_program.local?(rule)
        @wl_program.rewrite_non_local(rule)
        localcolls = @wl_program.flush_new_local_declaration
        # FIXME in case of full delegation zero is allowed
        raise WLError, "one intermediary collection should have been generated while splitting a non-local rule instead of #{localcolls.length}" if localcolls.length > 1
        intercoll = localcolls.first
        add_collection(intercoll)
        localrules = @wl_program.flush_new_rewritten_local_rule_to_install
        raise WLError, "one local rule should have been generated while splitting a non-local rule instead of #{localrules.length}" if localrules.length > 1
        rule = localrules.first
        @relation_to_declare.merge!(@wl_program.flush_new_relations_to_declare_on_remote_peer){|key,oldv,newv| oldv<<newv}
        @rules_to_delegate.merge!(@wl_program.flush_new_delegations_to_send){|key,oldv,newv| oldv<<newv}
      end
      # if a fully non-local rule is parsed a empty local rule is the result
      unless rule.nil?
        puts "Adding a rule: #{wlpg_rule}" if @options[:debug]
        translate_rule(rule)
        @need_rewrite_strata = true
        return rule.rule_id, rule.show_wdl_format
      end
    end

    # Make program is called in the initializer of the WL instance. Its role is
    # to create the bud structure corresponding to the wl_program instance
    # loaded.
    #
    # In detail, it create and add methods to this class. The methods created
    # have a name that correspond at a pattern that will be recognized by bud
    # such as __bootstrap__... or __bloom__... It also call the table or scratch
    # methods needed to declare the bud collection to use for this program
    #
    # TODO: add in schema init support for channel to declare new channel other
    # than the builtin :chan
    #
    def make_bud_program
      if @options[:debug]
        WLTools::Debug_messages.h2(WLTools::Debug_messages.begin_comment comment="Peer #{@peername} make program parse input file from WLGrammar to wlvocabulary internal representation")
        WLTools::Debug_messages.h3 "make_program start generate_schema"
      end
      @wl_program.wlcollections.each_value {|s| add_collection(s)}
      if @options[:debug]
        WLTools::Debug_messages.h3 "make_program start generate_facts"
      end
      # :delay_fact_loading is used in application to delay facts loading when
      # wrappers needs to be defined and bind before we can add facts
      if @options[:delay_fact_loading]
        @program_loaded = false
      else
        generate_bootstrap(@wl_program.wlfacts,@wl_program.wlcollections)
        @program_loaded = true
      end
      # #WLTools::Debug_messages.h3 "make_program translate" if @options[:debug]
      WLTools::Debug_messages.h2(WLTools::Debug_messages.end_comment comment) if @options[:debug]
      create_rule_blocks
    end

    # The generate_bootstrap method creates an array containing all extensional
    # facts information that can be read by the rule_init method (private) of
    # WLBud(see WLBud initializer).
    #
    # This create the block called bootstrap containing the fact for the initial
    # state of the peer.
    #
    # TODO optimize @wlfacts : transform it into a hash with
    # key=collection_name, value=array of facts in col. This will avoid a lot of
    # overhead.
    #
    def generate_bootstrap(facts,collections)
      if collections.empty? then puts "no relations yet..." if @options[:debug]; return; end
      if facts.empty? then puts "no facts yet..." if @options[:debug]; return; end
      str="{\n"
      collections.each_value {|wlcollection|
        tbl=[]
        @wl_program.disamb_peername!(wlcollection)
        facts.each {|wlf| tbl << wlf.content if wlf.fullrelname.eql?(wlcollection.atom_name)}
        str << "#{wlcollection.atom_name} <= " + tbl.inspect + ";\n"
      }
      str << "}"
      block = eval("Proc.new" + str)
      # #this is the same as what is done in bootstrap method in monkeypatch.rb
      meth_name = "__bootstrap__#{self.class.to_s}".to_sym
      self.class.send(:define_method, meth_name, block)
    end

    # The create_rule_blocks_rules method creates Bloom blocks from previously
    # parsed rules in @wl_program, for each local rules ie.
    # * the rules in +wl_program#localrules+
    # * the rules in +wl_program#rewrittenlocal+
    #
    def create_rule_blocks
      WLTools::Debug_messages.h2(WLTools::Debug_messages.begin_comment comment="Peer #{@peername} translate wlvocabulary internal representation into bud rules") if @options[:debug]
      if @wl_program.localrules.nil? || @wl_program.localrules.empty?
        puts 'no local rule to translate' if @options[:debug]
      else
        @wl_program.localrules.each {|wlrule| translate_rule wlrule }
      end
      if @wl_program.rewrittenlocal.nil? || @wl_program.rewrittenlocal.empty?
        puts 'no rewritten rule to translate' if @options[:debug]
      else
        @wl_program.rewrittenlocal.each {|wlrule| translate_rule wlrule}
      end
      WLTools::Debug_messages.h2(WLTools::Debug_messages.end_comment comment) if @options[:debug]
    end

    # Insert or delete facts in collections according to messages received from
    # channel. facts should respect {WLPacketData.valid_hash_of_facts} format
    #
    # Collections in which to add facts are suppose to support <+ operator
    #
    # @return [Hash, Hash] valid and error, valid is a list of facts that have
    # been successfully inserted, err is a list of facts that has not been
    # insert due to error in the format !{["relation_name", [tuple]] => "error
    # message"}
    #
    # TODO customize according to the type of relation in which facts are
    # inserted
    #
    def insert_updates(facts)
      valid = {}
      err = {}
      facts.each_pair do |k,tuples|
        relation_name = k
        # translate into internal relation name and check for existence of
        # relation
        relation_name = k.gsub /@/, "_at_" if k.to_s.include?'@'
        if @wl_program.wlcollections.has_key? relation_name
          arity = @wl_program.wlcollections[relation_name].arity
          tuples.each do |tuple|
            if tuple.is_a? Array or tuple.is_a? Struct
              if tuple.size == @wl_program.wlcollections[relation_name].arity
                begin
                  tables[k.to_sym] <+ [tuple]
                  (valid[k] ||= []) << tuple
                rescue StandardError => error
                  err[[k,tuple]]=error.inspect
                end
              else
                err[[k,tuple]] = "fact of arity #{tuple.size} in relation #{k} of arity #{arity}"
              end
            else
              err[[k,tuple]] = "fact in relation #{k} with value \"#{tuple}\" should be an Array or struct instead found a #{tuple.class}"
            end
          end # tuples.each do |tuple|
        else
          err[[k,tuples]] = "relation name #{k} translated to #{relation_name} has not been declared previously"
        end
      end # end facts.each_pair
      return valid, err
    end # end insert_updates

    # Read incoming packets on the channels and format them into an array of
    # WLPacketData
    #
    # @return [Array] array of WLPacketData
    #
    def read_packet_channel
      return chan.read_channel(@options[:debug])
    end

    # This method aggregates all the fact, rules and declarations of each peer
    # in a single packet for this peer. This method allow to be sure that facts
    # and rules deduce at the same timestep will be received in the remote peer
    # at the same timestep.
    #
    # TODO: optimization this fact aggregation is a useless overhead that can be
    # avoid if I create as many sbuffer collection as non-local relation in head
    # of rules.
    #
    def write_packet_on_channel
      packets_to_send = []
      facts_to_send = aggregate_facts(sbuffer)
      peer_to_contact = Set.new(facts_to_send.keys)
      peer_to_contact.merge(@rules_to_delegate.keys)
      if @options[:wl_test]
        @wl_callback.each_value do |callback|
          if callback[0] == :callback_step_write_on_chan
            block = callback[1]
            unless block.respond_to?(:call)
              raise WLErrorCallback,
                "Trying to call a callback method that is not responding to call #{block}"
            end
            block.call(self, facts_to_send, peer_to_contact)
          end
        end
      end
      peer_to_contact.each do |dest|
        packet = WLPacket.new(dest, @peername, @budtime)
        packet.data.facts = facts_to_send[dest]
        packet.data.rules = @rules_to_delegate[dest]
        packet.data.declarations = @relation_to_declare[dest]
        packets_to_send << packet.serialize_for_channel
      end
      if @options[:wl_test]
        @test_send_on_chan = Marshal.load(Marshal.dump(packets_to_send))
        @wl_callback.each_value do |callback|
          if callback[0] == :callback_step_write_on_chan_2
            block = callback[1]
            raise WLErrorCallback, "Trying to call a callback method that is not responding to call #{block}" unless block.respond_to?(:call)
            block.call(self, packets_to_send)
          end
        end
      end
      packets_to_send.each do |packet|
        chan <~ [packet]
      end
      if @options[:debug]
        puts "BEGIN display what I wrote in chan to be send"
        # #puts chan.pending.inspect
        puts "number of facts: #{chan.pending.size}, sample of ten first keys #{chan.pending.keys[1..10].inspect}"
        puts "chan in yaml"
        # #y chan.pending
        puts "END"
      end
    end

    # Register a callback triggered during the tick at the moment specified by
    # *step*, it will execute &blk
    #
    # Note that option :wl_test must be set for the wlbud instance otherwise
    # callback are ignored. This callback are used for test and must not be used
    # for production.
    #
    # * :callback_step_received_on_chan called in the tick just after inbound
    #   has been flushed into chan
    # * :callback_step_write_on_chan, :callback_step_write_on_chan_2 two
    #   callback called just after writing on channel
    # * :callback_step_end_tick is called at the end of the tick with self as
    #   argument
    #
    # === return
    # the callback id useful to unregister the callback later
    #
    def register_wl_callback(step, &blk)
      unless @wl_callback_step.include? step
        raise WLBud::WLErrorCallback, "no such callback step #{step}"
      end
      if @wl_callback.has_key? @wl_callback_id
        raise WLBud::WLErrorCallback, "callback duplicate key"
      end
      @wl_callback[@wl_callback_id] = [step, blk]
      cb_id = @wl_callback_id
      @wl_callback_id += 1
      return cb_id
    end

    # Unregister the callback by id given during registration
    #
    def unregister_wl_callback(cb_id)
      raise WLBud::WLErrorCallback, "missing callback: #{cb_id.inspect}" unless @wl_callback.has_key? cb_id
      @wl_callback.delete(cb_id)
    end

    # Create if needed the directory for the rules if rule_dir does not exists
    # or is not writable.
    #
    # @return [String] the name of dir where rule files will be stored
    #
    def create_rule_dir(rule_dir)
      if rule_dir.nil? or not File.directory?(rule_dir) or not File.writable?(rule_dir)
        rule_dir ||= "wlrdir_#{@peername}_#{Time.now}_#{self.class}_#{@peername.object_id}"
        base_dir = WL::get_path_to_rule_dir
        unless (File::directory?(base_dir))
          Dir.mkdir(base_dir)
        end
        rule_dir = File.join(base_dir,WLTools.friendly_filename(rule_dir))
        unless (File::directory?(rule_dir))
          Dir.mkdir(rule_dir)
        end
      end # unless File.directory?(rule_dir)
      return rule_dir
    end # create_rule_dir

    # Clear the content of the rule dir for this peer
    #
    def clear_rule_dir
      unless @rule_dir.nil?
        Dir.foreach(@rule_dir) do |filename|
          file_to_delete = File.join(@rule_dir, filename)
          File.delete(file_to_delete) if File.file?(file_to_delete)
        end
        Dir.rmdir(@rule_dir)
        return true
      else
        # silent quit
        return false
      end
    end

    # a default path to create a rule dir
    def self.get_path_to_rule_dir
      base_dir = File.expand_path(File.dirname(__FILE__))
      return File.join(base_dir, RULE_DIR_NAME)
    end
  end # class WL

  # Build a packet to write on the channel with all the standard meta-data. It
  #   is recommended to use this method to generate packet of standard format.
  #
  # ==== Attributes
  #
  # * +dest+ - IP of the peer on which to send the data
  # * +facts+ - list of facts order by relations
  # * +delegations+ - rules to delegate
  # * +declarations+ - new relations to declare (must correspond to one of the
  #   relations used in the delegations of this package).
  #
  # ==== Examples
  #
  #    none
  #
  def packet_builder(dest,facts,delegations,declarations)
    Packet.new(dest, @peername, @budtime, nil)
  end

  # This method group facts by relations and by peers.
  #
  # ==== return a hash
  #
  # * +key+ destination
  # * +value+ hash of relation with their facts
  def aggregate_facts(fact_buffer)
    sto = fact_buffer.pro{ |t| t.to_a }
    facts_by_peer = WLTools::merge_multivaluehash_grouped_by_field(sto,0)
    facts_by_peer_and_relations = {}
    facts_by_peer.each_pair do |k, v|
      facts_by_peer_and_relations[k] = WLTools::merge_multivaluehash_grouped_by_field(v,0)
    end
    #          if @options[:debug]
    #            puts "BEGIN display aggregate facts format"
    #            puts "facts_by_peer_and_relations with inspect"
    #            puts facts_by_peer_and_relations.inspect
    #            # puts "facts_by_peer_and_relations in yaml"
    #            # y facts_by_peer_and_relations
    #            puts "END"
    #          end
    return facts_by_peer_and_relations
  end

  def pretty_string(print_table)
    s1 = print_table[0].to_s + "\t"
    s2 = print_table[1].inspect + "\t"
    s3 = print_table[2].to_s
    return s1 + s2 + s3
  end

  # #This method formats a fact table to be #processed by WebdamExchange manager
  # module.
  #
  def fact_we_output(print_table)
    s1 = print_table[0].to_s
    s2 = print_table[1].inspect
    s3 = print_table[2].to_s
    s1.strip!;s2.strip!;s3.strip!
    return "[fact]:" + s1 + ":"+ s2 + ":" + s3
  end
  #     Oldies
  #
  # Takes in an array of rule tuples and adds them to the current WLBud
  # instance. The first element of the tuple is the rule name, and the second
  # element is the rule content.
  #
  #    def rule_init (rule)
  #      create_method(rule.first,rule.last) unless rule.nil?
  #    end
  # Create for this bud engine a new method representing a rule to add with a
  # name which should be a Symbol and proc should be a Proc.
  #
  # Basically it check the type of both argument and create a call to the
  # private define_method
  #    def create_method(name, proc)
  #      raise WLErrorGrammarParsing unless name.is_a?(Symbol)
  #      raise WLErrorGrammarParsing unless proc.is_a?(Proc)
  #      # Call the Module#define_method that create an instance method with name
  #      # and proc as block this is equivalent to the following call:
  #      # self.define_method(name, proc)
  #      self.class.send(:define_method, name, proc)
  #    end

end

module Bud
  def self.done_rewrite= (d)
    @done_rewrite = d
  end

  def self.done_rewrite
    @done_rewrite
  end
end

